# Hacking Hashing in Competitive Programming

## Introduction

During Competitive Programming contests, participants compete for
the maximum number of problems solved and earliest time solved.

One of the most popular Competitive Programming websites,
Codeforces features a "hacking" system where after you have
submitted a solution that passes the tests provided by the
problem-setter, you have the option to try to find a counter-test
for a submission by another participant.

Although hashing is a very powerful tool for competitive
programming, it's necessary to take precautions like introducing runtime
randomness into a program to make it non-deterministic and thus
more robust against hacking in a contest.

I researched the two most popular applications of hashing in
Competitive Programming in C++: Hashtables and Polynomial String Hashing.

## Defining Robustness

Due to the nature of hashing, for all hashes with more possible states than 
hash values, with an unlimited number of attempts and computing power, 
a collision will be found such that M != M' and H(M) == H(M').

The Codeforces platform typically gives a participant +100 points for a
successful hacking attempt against another competitor and
-50 points for unsuccessful tries. In addition, the hacking period is
typically around 12 hours after the end of a contest. These parameters 
give more reasonable bounds for the number of attempts and the 
computing power of an adversary.

A robust hashing solution would be one that cannot be hacked in a handful of
attempts using an average computer within 12 hours with high probability.

## Pseudo-Random Number Generators (PRG)

In order to make hashing solutions robust against hacking attempts,
runtime randomness can be added using a pseudo-random number generator
with a random seed.

### rand() : BAD

The C-standard library function rand is legacy code that is not
suitable for most applications today. The function returns a
library-dependent value between 0 and RAND_MAX but the C-standard
only guarantees that RAND_MAX is at least 32767 or $2^{15} - 1$. 
[source](https://cplusplus.com/reference/cstdlib/RAND_MAX/)

### Mersenne Twister : GOOD

32-bit and 64-bit versions of the Mersenne Twister random-number
generator are included in the C++ standard library as mt19937.
The GCC compiler also includes SIMD-oriented fast Mersenne Twister
sfmt19937.

Pros:
- Can be initialized with a single line due to being in the C++ standard library
- Easy to generate distributions by using with std::uniform_int_distribution

Cons:
See [It Is High Time We Let Go Of The Mersenne Twister - Sebastiano Viglia (2019, preprint)](http://arxiv.org/abs/1910.06437)
- "Fails statistical tests designed to find bias in linear generators"
- Uses an excessive 19937 bits of state
- Slow

In the context of competitive programming where implementation speed is 
a large factor, std::mt19937 is still a very good PRG.

### Xoshiro : GOOD

New PRGS such as Xoshiro (xor, shift, rotate) only
utilize a handful of operations such as add, xor, shift, and rotate
which each only take a single cpu instruction on modern hardware.

Pros:
- Very fast in comparison to std::mt19937
- Small state (256 bits for xoshiro256 64-bit generator)
- Robust under test suites such as TestU01 BigCrush

Cons:
- Not in C++ standard library, requires additional code
- Requires additional code to implement fair mapping to a range compared
to simply using std::uniform_int_distribution with Mersenne Twister
  - [Fast Random Integer Generation in an Interval - Daniel Lemire (2018)](https://arxiv.org/abs/1805.10941)
- not cryptographically secure, easily reversible

It is not worth using xoshiro or xoroshiro PRGS in competitive programming
even if template code is set up beforehand since the speed difference
is not meaningful. However in Heuristics contests such as 
Atcoder Heuristic Contest, the speed difference of the PRG allows 
for more iterations of non-deterministic algorithms like 
Simulated Annealing and thus can lead to a competitive advantage.

## Seeding PRGs

### Fixed seed : BAD
With a fixed seed, the sequence generated by a PRG is also fixed.
The sequence can be generated once to find an adversarial testcase.

### time(nullptr) : BAD
Like rand, time is part of the C standard library.
"The value returned generally represents the number of seconds since
00:00 hours, Jan 1, 1970 UTC (i.e., the currentÂ _unix timestamp_)"
The return value is a 32-bit value that increments every second.
This value is very predictable. By finding the fixed sequence for a
time range, for example it is possible to generate 60 collision sequences
for a time range of a minute and combine the results to generate an
adversarial testcase. As long as the test is ran on the server within 
the next minute, this will result in a successful hacking attempt.

### std::chrono::steady_clock : GOOD
```c++
chrono::steady_clock::now().time_since_epoch().count()
```
This returns a 64-bit value with significantly higher precision 
in comparison to the previous ctime.
Although the top bits of the number are very predictable like ctime,
the lower bits are very unpredictable.
Even calling the function above twice in two successive lines in a local
program yields differing lower bits.

Since the lower bits are very volatile, combined with the avalanche effect in 
good PRGs, it is not feasible to take advantage of this value when 
used as a seed.

## Hashtables
### How std::unordered_map works
The C++ standard library hashtable std::unordered_map works in the following
way. 
1. First, std::hash is called on the key value. 
2. The hashed value is distributed to one of the buckets by taking 
hash % bucket-count. The bucket size is always a prime number.
3. When different key values are mapped to the same bucket, std::unordered_map
uses separate chaining to deal with collisions.
4. When the number of items in the data structure go over a set load factor,
the bucket-count is increased.

### Hacking
Several parts of this implementation make it vulnerable to hacking.  
First, std::hash when called on integer values acts as the 
**identity function**, meaning the value is not actually hashed at all.  
Second, the prime numbers used for the bucket-counts are fixed for each compiler
version.  
Third, the load factor by default is 1.0, meaning that the hashtable
bucket-size does not increase until the number of elements equals the 
previous bucket-size.

By calling std::unordered_map::bucket_size() while adding 
elements, it is possible to find the set bucket sizes for the 
specific compiler version.

Suppose a problem involves finding the number of duplicated values 
from a sequence of `n` integers. With few collisions, the expected running
time using a hashtable is O(n) to process `n` numbers.

By instead adding in equivalent values modulo the last bucket-count, 
an adversary can force a collision chain of length `n`.
Instead of each add and lookup operations taking about O(1) time,
the time complexity could increase to up to O(n) for each operation
and cause a "Time limit exceeded" verdict.

[Example here](https://github.com/takeuchi-masaki/hacking-hashing/blob/main/hashmap/check_bucketsize.cpp)

### Robust solution
One way to make Hashtables robust against the previous attack is to 
actually hash the input value.
First created for the Java language, the Splitmix PRG takes in a 
state value and applies xorshift operations to create the next state.

This can be added as a hash function to use with std::unordered_set 
or std::unordered_map.

However, since [Splitmix can easily be reversed](https://github.com/takeuchi-masaki/hacking-hashing/blob/main/hashmap/reverse_splitmix.cpp)
, runtime randomness must be additionally added to the funciton.

```c++
struct custom_hash { // https://codeforces.com/blog/entry/62393
    constexpr static uint64_t splitmix64(uint64_t x) { // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }
    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
template<class K> using hashset = unordered_set<K, custom_hash>;
template<class K, class V> using hashmap = unordered_map<K, V, custom_hash>;
```

## Polynomial String Hashing

### Birthday Attack
When 

### Thue-Morse Sequence
The Thue-Morse sequence is "a binary sequence obtained by starting with
0 and successivel appending the Boolean complement of the sequence so far".

This can be used to attack hashing solutions that let the
result of polynomial hashing overflow using the 2^n integer bound
when the base is any odd number. 
Let the '0's of a Thue-Morse sequence of length of a power of 2 be replaced
by 'A' and '1's with 'B'.
This AB string and its inverse (all 'A' swapped with 'B' and vice versa)
collide 

### Other attacks against Fixed-Base Fixed-Modulo hashes
Since the birthday attack takes about 2^30 operations against a 2^60 modulus,
hashing the same string twice with two different bases or modulus can
be an effective strategy against it.
However, other attacks are able to quickly find collisions against 
64-bit modulos and double-hashing.

A [codeforces user recently created a website](https://codeforces.com/blog/entry/129538)
that runs a Lattice-Reduction attack locally within the browser.
For example, this attack was able to generate a collision against
a double hash with modulo (2^61 - 1) within 2 seconds, whereas 
it would be impractical to attempt to find a collision using a
birthday attack.

## Robust solution
Hashing solutions can be vulnerable to attacks even using 
techniques such as double-hashing. 
However, randomizing the base for the polynomial string hashing at runtime 
and using a large modulo is enough to make it robust against hacking.


## References
- [It is high time we let go of the Mersenne Twister - Sebastian Vigna (2019, preprint)](http://arxiv.org/abs/1910.06437)
  - http://arxiv.org/abs/1910.06437
- [Blowing up unordered_map, and how to stop getting hacked on it - Codeforces blog](https://codeforces.com/blog/entry/62393)
  - https://codeforces.com/blog/entry/62393
- [Internet Problem-solving Contest 2014 Problem H: Hashsets Solution](https://ipsc.ksp.sk/2014/real/solutions/booklet.pdf)
  - https://ipsc.ksp.sk/2014/real/solutions/booklet.pdf
- [Fast Splittable Pseudorandom Number Generators - Guy L. Steele, Doug Lea, and Christine H. Flood (2014)](https://dl.acm.org/doi/abs/10.1145/2660193.2660195)
- [On the mathematics behind rolling hashes and anti-hash tests](https://codeforces.com/blog/entry/60442)
  - https://codeforces.com/blog/entry/60442
