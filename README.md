# Hacking Hashing in Competitive Programming

## Introduction

During Competitive Programming contests, participants compete for
the maximum number of problems solved and earliest time solved.

One of the most popular Competitive Programming websites,
Codeforces features a "hacking" system where after you have
submitted a solution that passes the tests provided by the
problem-setter, you have the option to try to find a counter-test
for a submission by another participant.

Although hashing is a very powerful tool for competitive
programming, it's necessary to take precautions like introducing runtime
randomness into a program to make it non-deterministic and thus
more robust against hacking in a contest.

I researched the two most popular applications of hashing in
Competitive Programming in C++: Hashtables and Polynomial String Hashing.

## Defining Robustness

Due to the nature of hashing, for non-trivial cases there are always
more possible states than hash values. Therefore, with an unlimited number of
attempts all hashing solutions will eventually have collisions.

The Codeforces platform gives a participant +100 points for a
successful hacking attempt against another competitor and -50 points for
unsuccessful tries. In addition, the hacking period is typically around 12
hours after the end of a contest. These parameters give a more reasonable
bounds for the number of attempts and the computing power of an adversary.

A robust hashing solution would be one that cannot be hacked in 1~2 attempts
using an average computer within 12 hours with high probability.

## Pseudo-random Generators (PRNG)

### rand() : BAD

The C-standard library function rand is legacy code that is not
suitable for most applications today. The function returns a
library-dependent value between 0 and RAND_MAX but the C-standard
only guarantees that RAND_MAX is at least 32767 or $2^{15} - 1$.

### Mersenne Twister : GOOD

32-bit and 64-bit versions of the Mersenne Twister random-number
generator are included in the C++ standard library as mt19937.
The GCC compiler also includes SIMD-oriented fast Mersenne Twister
sfmt19937.

Pros:
- In C++ standard library, can initialize with a single line
- Easy to generate distributions by using std::uniform_int_distribution

Cons:
See [It Is High Time We Let Go Of The Mersenne Twister - Sebastiano Viglia (2019, preprint)](http://arxiv.org/abs/1910.06437)
- "Fails statistical tests designed to find bias in linear generators"
- Uses an excessive 19937 bits of state
- Slow

In the context of competitive programming where implementation speed is 
a large factor, std::mt19937 is still a very good PRNG.

### Xoshiro : GOOD

New PRNGS such as Xoshiro (xor, shift, rotate) only
utilizes a handful of operations such as add, xor, and shift which
are each a single instruction on modern cpus.

Pros:
- Very fast in comparison to std::mt19937
- Small state (256 bits for xoshiro256 64-bit generator)
- Robust under test suites such as TestU01 BigCrush

Cons:
- Not in C++ standard library, requires additional code
- Requires additional code to implement fair mapping to a range compared
to simply using std::uniform_int_distribution with Mersenne Twister
  - [Fast Random Integer Generation in an Interval - Daniel Lemire (2018)](https://arxiv.org/abs/1805.10941)

It is not worth using xoshiro or xoroshiro PRNGS in competitive programming
even if template code is set up beforehand since the speed difference
is not meaningful. In Heuristics contests,
(Atcoder Heuristic Contest, Topcoder Marathon Match) the speed difference of
the PRNG may allow for more iterations of non-deterministic algorithms like
Simulated Annealing or Beam Search and could be competitive advantage.

## Seeding PRNGs

### Fixed seed : BAD
With a fixed seed, the sequence generated by a PRNG is also fixed.
The sequence can be generated once to find an adversarial testcase.

### time(nullptr) : BAD
Like rand, time is part of the C standard library.
"The value returned generally represents the number of seconds since
00:00 hours, Jan 1, 1970 UTC (i.e., the currentÂ _unix timestamp_)"
The return value is a 32-bit value that increments every second.
This value is very predictable. By finding the fixed sequence for a
time range, for example it is possible to generate 60 collision sequences
for a time range of a minute and combine the results to generate an
adversarial testcase. As long as the test is ran on the server within 
the next minute, this will result in a successful hacking attempt.

### std::chrono::steady_clock,  : GOOD
```c++
chrono::steady_clock::now().time_since_epoch().count()
```
This returns a 64-bit value with significantly higher precision 
in comparison to the previous ctime.
Although the top bits of the number are very predictable like ctime,
the lower bits are very unpredictable.
Even calling the function above twice in two successive lines in a local
program yields differing lower bits.

Due to the avalanche effect in good PRNGs, it is not feasible to take
advantage of this value when used as a seed.

## Hashtables
### How std::unordered_map works
The C++ standard library hashtable std::unordered_map works in the following
way. 
1. First, std::hash is called on the key value. 
2. The hashed value is distributed to one of the buckets by taking 
hash % bucket-size. The bucket size is always a prime number.
3. When different key values are mapped to the same bucket, std::unordered_map
uses chaining to deal with collisions.
4. When the number of items in the data structure go over a set load factor,
the bucket size is increased.

### Hacking
Several parts of this implementation make it vulnerable to hacking.  
First, std::hash when called on integer values acts as the identity function,
meaning the value is not actually hashed.  
Second, the prime numbers used for the bucketsize are fixed for each compiler
version.  
Third, the load factor by default is 1.0, meaning that the hashtable
bucket-size does not increase until the number of elements equals the 
previous bucket-size.

By calling std::unordered_map::bucket_size() while adding additional 
elements, it is possible to find the set bucket sizes for the 
specific compiler version.

Suppose a problem involves finding the number of duplicated values 
from a sequence of 10^6 integers. With few collisions, the expected running
time using a hashtable is O(n) to process `n` numbers.


### Robust solution
One way to make Hashtables robust against the previous attack is to actually
hash the input value. The splitmix64 algorithm is another PRNG with
the additional property that each


## Polynomial String Hashing

### Thue-Morse Sequence
The Thue-Morse sequence can be used to attack hashing solutions that
use a 2^n modulus. In other words, the polynomial overflows by the
bounds 

### Birthday Attack
A simple and very effective solution is the Birthday attack.
Given 

### Other attacks against Fixed-Base Fixed-Modulo hashes
Other attacks are able to quickly find collisions against 64-bit modulos
and double-hashing.

## Robust solution
Randomizing the base is sufficient to prevent hacks.


## References
- It is high time we let go of the Mersenne Twister - Sebastian Vigna (preprint)
  - http://arxiv.org/abs/1910.06437
- https://en.wikipedia.org/wiki/Xorshift
- https://cplusplus.com/reference/ctime/time/
- Blowing up unordered_map, and how to stop getting hacked on it
	- https://codeforces.com/blog/entry/62393
- https://cplusplus.com/reference/unordered_map/unordered_map/
- On the mathematics behind rolling hashes and anti-hash tests
	- https://codeforces.com/blog/entry/60442
- https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/src/shared/hashtable-aux.cc
- https://www.vincent-lunot.com/post/playing-with-pseudo-random-number-generators-part-3/
